function __git_ps1_quick_summary {
	git branch > /dev/null 2>&1
	if [ "$?" == "0" ]; then
		echo -ne " \e[1;33m⚡\e[00m "
		echo -ne "\e[0;37m"
		echo -n $(git branch 2>&1 | grep '^*' | head -1 | sed -e 's/* //')
		echo -ne "\e[00m"
		UNSTAGED_CHANGES="$(git status --porcelain | grep "^[ /?]" | cut -c 2 | sort | uniq | sed 's/ *//g' | tr -d '\n')"
		if [ "0" != "$(echo -n $UNSTAGED_CHANGES | wc -m)" ]; then
			echo -ne "\e[1;35m"
			echo -n " $UNSTAGED_CHANGES"
			echo -ne "\e[00m"
		fi
		STAGED_CHANGES="$(git status --porcelain | grep "^[^ /?]" | cut -c 1 | sort | uniq | sed 's/ *//g' | tr -d '\n')"
		if [ "0" != "$(echo -n $STAGED_CHANGES | wc -m)" ]; then
			echo -ne "\e[1;32m"
			echo -n " $STAGED_CHANGES"
			echo -ne "\e[00m"
		fi
		echo -ne " \e[1;33m⚡\e[00m"
	fi
}

if [ -f "$(brew --prefix)/etc/bash_completion.d/git-prompt.sh" ]; then
	source $(brew --prefix)/etc/bash_completion.d/git-prompt.sh
	GIT_PS1_SHOWDIRTYSTATE=true
	export PS1="${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$(__git_ps1)\[\033[1;31m\] ✪ \[\033[00m\]"
else
	export PS1="${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$(__git_ps1_quick_summary)\[\033[1;31m\] ✪ \[\033[00m\]"
fi

# Mac bash autocompletes
if [ -f $(brew --prefix)/etc/bash_completion ]; then
  source $(brew --prefix)/etc/bash_completion
fi

source ~/.bash_complete_fab

function activate {
	deactivate > /dev/null 2>&1
	UP="."
	while true; do
		REAL="$(realpath $UP)"
		if [ "/" == "$REAL" ]; then
			echo "no virtualenv in tree"
			return 1
		elif [ -d "$REAL/venv" ]; then
			echo "activating $REAL/venv"
			source "$REAL/venv/bin/activate"
			return 0
		elif [ -d "$REAL/env" ]; then
			echo "activating $REAL/env"
			source "$REAL/env/bin/activate"
			return 0
		fi
		UP="$UP/.."
	done
}

alias todo="~/opt/bin/todo.sh -d ~/.todo.cfg"
source ~/.todo_completion
complete -F _todo todo

alias markdown='redcarpet --parse-fenced-code-blocks'

calc(){ awk "BEGIN{ print $* }" ;}

export PATH="$PATH:$(realpath ~/opt/bin)"
export SHORT_ATTENTION_SPAN_DOCBOOK_PATH="/opt/docbook"

export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin

type gzcat > /dev/null 2>&1
if [ $? != 0 ]; then
	alias gzcat='gunzip -c'
fi

which gvim > /dev/null 2>&1
if [ $? != 0 ]; then
  alias gvim='mvim'
fi

ANDROID="/Users/jmhobbs/Library/Android/sdk/platform-tools"
if [ -d $ANDROID ]; then
  export PATH="$PATH:$ANDROID"
fi

# Homebrew
if [ -d "/usr/local/sbin" ]; then
  export PATH="/usr/local/sbin:$PATH"
fi

alias quickserve="php -S localhost:6060"

# cd, relative to .git root
function gcd {
  ROOT="$(git root)"
  EXIT="$?"

  if [ "0" != "$EXIT" ]; then
    echo "Not in a git repo!"
  else
    cd $ROOT/$1
  fi
}

### Added by the Heroku Toolbelt
export PATH="/usr/local/heroku/bin:$PATH"

# rbenv
export PATH="$HOME/.rbenv/bin:$PATH"
eval "$(rbenv init -)"

eval "$(direnv hook bash)"

alias stripcolors="perl -pe 's/\e\[?.*?[\@-~]//g'"


which most > /dev/null 2>&1
if [ $? == "0" ]; then
  export MANPAGER="most"
else
  man() {
    env \
      LESS_TERMCAP_mb=$'\e[1;31m' \
      LESS_TERMCAP_md=$'\e[1;31m' \
      LESS_TERMCAP_me=$'\e[0m' \
      LESS_TERMCAP_se=$'\e[0m' \
      LESS_TERMCAP_so=$'\e[1;44;33m' \
      LESS_TERMCAP_ue=$'\e[0m' \
      LESS_TERMCAP_us=$'\e[1;32m' \
      man "$@"
  }
fi
